#include "uart_rx.h"

/*
ISR(TIMER0_COMPA_vect)
{
	TXPORT = (TXPORT & ~(1 << TXD)) | ((txbyte & 0x01) << TXD); // Выставляем в бит TXD младший бит txbyte
	txbyte = (txbyte >> 0x01) + 0x8000;	// Двигаем txbyte вправо на 1 и пишем 1 в старший разряд (0x8000)
	if(txbitcount > 0)			// Если идет передача (счетик бит больше нуля),
	{
		txbitcount--;			// то уменьшаем его на единицу.
	}
}
*/

ISR(TIMER0_COMPB_vect) //здесь происходит зависание
{
	if(rxbitcount == 0x09)
		fGetId = 1;// для запуска чтения из uart
	
	if(RXPORT & (1 << RXD))			// Проверяем в каком состоянии вход RXD
		rxbyte |= 0x80;			// Если в 1, то пишем 1 в старший разряд rxbyte
	
	if(--rxbitcount == 0)			// Уменьшаем на 1 счетчик бит и проверяем не стал ли он нулем
	{
		timeout = 0;
		TIMSK0 &= ~(1 << OCIE0B);	// Если да, запрещаем прерывание TIM0_COMPB
		TIFR0 |= (1 << OCF0B);		// Очищаем флаг прерывания TIM0_COMPB
		EIFR |= (1 << INTF1);		// Очищаем флаг прерывания по INT1
		EIMSK |= (1 << INT1);		// Разрешаем прерывание INT1
	}
	else
	{
		rxbyte >>= 0x01;		// Иначе сдвигаем rxbyte вправо на 1
	}
}

ISR(INT1_vect)
{
	timeout = 1;
	//PIND |= 1<<PD4;//debug
	TimerTempCount = 0; //сбрасываем счетчик чтения температуры
	
	rxbitcount = 0x09;			// 8 бит данных и 1 стартовый бит
	rxbyte = 0x00;				// Обнуляем содержимое rxbyte
	if(TCNT0 < (BAUD_DIV / 2))		// Если таймер не досчитал до середины текущего периода
	{
		OCR0B = TCNT0 + (BAUD_DIV / 2);	// То прерывание произойдет в текущем периоде спустя пол периода
	}
	else
	{
		OCR0B = TCNT0 - (BAUD_DIV / 2);	// Иначе прерывание произойдет уже в следующем периоде таймера
	}
	EIMSK &= ~(1 << INT1);			// Запрещаем прерывание по INT1
	TIFR0 |= (1 << OCF0A) | (1 << OCF0B);	// Очищаем флаги прерываний TIM0_COMPA (B)
	TIMSK0 |= (1 << OCIE0B);		// Разрешаем прерывание по OCR0B
}

/*
void uart_send(uint8_t tb)
{
	while(txbitcount);		// Ждем пока закончится передача предыдущего байта
	txbyte = (tb + 0xFF00) << 0x01; // Пишем в младшие разряды txbyte данные для передачи и сдвигаем влево на 1
	txbitcount = 0x0A;		// Задаем счетчик байт равным 10
}
*/

int8_t uart_recieve(uint8_t* rb)
{
	if(rxbitcount < 0x09)		// Если счетчик бит на прием меньше 9
	{
		while(rxbitcount);	// Ждем пока завершится текущий прием
		*rb = rxbyte;		// Пишем по адресу указателя принятый байт
		rxbitcount = 0x09;	// Восстанавливаем значение счетчика бит
		return (*rb);		// Возвращаемся
	}
	else
	{
		return (-1);		// Иначе возвращаем -1 (принимать нечего)
	}
}

void uart_init()
{
	//txbyte = 0xFFFF;		// Значение буфера на передачу - все единицы
	rxbyte = 0x00;			// Значение буфера на прием - все нули
	//txbitcount = 0x00;		// Значение счетчика преедаваемых бит - ноль (ничего пока не передаем)
	rxbitcount = 0x09;		// Значение счетчика бит на прием - 9 (ожидаем возможного приема)
	
	//TXDDR |= (1 << TXD);		// Задаем направление порта на передачу как выход
	RXDDR &= ~(1 << RXD);		// Задаем направление порта на прием как вход
	//TXPORT |= (1 << TXD);		// Пишем единицу в выход TXD
	RXPORT |= (1 << RXD);		// Подтягиваем к единице вход RXD
	OCR0A = BAUD_DIV;		// Задаем значение регистра OCR0A в соответствии с бодрейтом
	//TIMSK0 |= (1 << OCIE0A);	// Разрешаем прерывание TIM0_COMPA
	TCCR0A |= (1 << CTC0);		// Режим таймера CTC (очистка TCNT0 по достижению OCR0A)
	TCCR0A |= T_DIV;		// Задаем скорость счета таймера в соответствии с делителем
	EICRA |= (1 << ISC11);		// Задаем прерывание INT1 по заднему фронту импульса
	EIMSK |= (1 << INT1);		// Разрешаем прерывание INT1
	//sei();				// Разрешаем прерывания глобально
}

int8_t GetId(uint8_t* buf, uint8_t len)
{
	static uint8_t count = 0;
	static uint8_t error_count = 0;
	
	uart_recieve((buf+count));
			
	if(count < (len-1)) // ждём приём 14 байт
	{
		count++;
	}
	else
	{
		if (*(buf+13) != 0x03) //если последний байт в буфере не 0х03(метка конца передачи) или кол-во одинаковых данных в приёме больше 6, то начинаем сначало
		{
			clear_buffer(buf,14);
			count = 0;
			error_count = 0;
			return 0;
		}
		if (error_count > 6)
		{
			count = 0;
			error_count = 0;
			return 0;
		}
		EIMSK &= ~(1 << INT1);			// Запрещаем прерывание по INT1
		TIMSK0 &= ~(1 << OCIE0B);	// запрещаем прерывание TIM0_COMPB
		TIFR0 |= (1 << OCF0B);		// Очищаем флаг прерывания TIM0_COMPB
		EIFR |= (1 << INTF1);		// Очищаем флаг прерывания по INT1
		count = 0;
		error_count = 0;
		return 1;
	}
	
	if (*buf != 0x02) // если первый байт в буфере не 0х02(метка начала передачи), то начинаем сначало
	{
		clear_buffer(buf,14);
		count = 0;
		//return 0;
	}
	
	if (count > 1)
	{
		if (*(buf+1) == *(buf+count)) // проверка на помехи
		{
			error_count++;
		}
	}

	return 0;
}